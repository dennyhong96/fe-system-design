## 1. General Requirements (Feature requirements)

- Pins should be placed in the form of masonary layout
- User can full details of pins
- Pin can be gif or picture (no videos)
- User can post the comments
- User can share the pin

## 2. Specific Requirements (Functional requirements, Platforms, Target Browsers, etc.)

- Support 95% browsers except for IE11
- Support wide range of devices (Desktop, Laptop, Tablet, Mobile Phone)
- Support offline mode
- Support short network band (bad internet connect)

## 3. Component Architechture

```TSX
<App>
  <Header>
    <NavLinks/>
    <SearchBox/>
    <ProfileControls/>
  </Header>
  <Router>
    <PinsFeedPage>
      <PinsGrid size="sm|md|lg">
        <Pin>
          <img/>
          <ControlPanel />
          <ActionMenu />
          {showDetail &&
            (<PinDetail>
              <img/>
              <Details/>
              <CommentList>
                <Comment/>
                <Comment/>
                <CommentInput/>
              </CommentList>
            </PinDetail>)}
        </Pin>
      </PinsGrid>
    </PinsFeedPage>
  </Router>
</App>
```

## 4. Masonary Layout

- Masonary grid
  - Grid items have different height
  - Grid items are positioned to fill the entire viewport
  - Each grid item is positioned absolutely
  - Each grid item's position & transform value is being calculated with JavaScript
- Infinite scroll
  - IntersectionObserver API
    - Detect if the last row of any of the last row of grid items is intersecting with a bottom sentinel element
    - When intersecting, load more data
  - Use element scroll event to detect if any of the last row of grid items has been scrolled to the bottom of the grid container
    - Need to set passive: true for the event listener to improve performace
- List virtualization
  - We have a constant number of grid item elements depending on different screen sizes
  - When we have scrolled to the bottom and have more data to display, we replace the data on those grid item elements with the new data, we re-use those constant number of elements, we do not append new elements

## 5. Data Entities

```typescript
interface IPin {
  authorId: number;
  userId: number;
  description: string;
  title: string;
  imageUrl: string;
}

interface IComment {
  id: numebr;
  pinId: number;
  authorId: number;
  content: string;
}

interface IUser {
  id: numebr;
  name: string;
}

// ...
```

## 6. Data API and protocol

```typescript
declare function getPins(
  apiKey: string,
  includeComments: boolean,
  cursor: number,
  minId: number,
  maxId: number
): Promise<IPin[]>;

declare function getComments(
  apiKey: string,
  pinId: boolean,
  pageSize: number,
  pageNumber: number
): Promise<IComments[]>;

// ...
```

## 7. Store Normalization

- Prevent nested data in store
- Prevent unnecessary list traversing
- Flattened, mapped key format
  - We can access entity/entities by an id with O(1) constant time

```typescript
interface IPinsStore {
  [pinId: number]: IPin;
}
interface IUsersPinsStore {
  [userId: number]: IPin[];
}
interface IUserStroe {
  [userId: number]: IUser;
}
interface ICommentsStore {
  [pinId: number]: IComments[];
}
```

```TSX
<PinsFeedPage> // const pinIds = await getPins()
  <PinsGrid pinIds={pinIds}>
    <Pin pinId={1}> // lookup IPinsStore by by pinId
      <img/>
      <ControlPanel />
      <ActionMenu />
      {showDetail && (
        <PinDetail>
          <img/>
          <Details/>
          <CommentList pinId={1}> // lookup ICommentsStore by pinId
            <Comment/>
            <Comment/>
            <CommentInput/>
          </CommentList>
        </PinDetail>)}
    </Pin>
  </PinsGrid>
</PinsFeedPage>
```

## 8. Optimization

- Network performance
- Rendering performance
- JavaScript performance
- PWA (offline access)

## 9. Accessbility
